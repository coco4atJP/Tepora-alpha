# 包括的コードレビューレポート

## 1. エグゼクティブサマリー

**Tepora** のコードベースは、特に最近の V2 リファクタリングにより、強固なアーキテクチャ基盤を示しています。`TeporaApp`（オーケストレーター）、`LLMService`（ステートレスなモデル実行）、`TeporaGraph`（ワークフローロジック）間の関心の分離は適切に実装されています。フロントエンドは、React と Zustand を使用したモダンなパターンを効果的に活用しています。

しかし、型安全性、エラー処理の粒度、およびテスト容易性に影響を与える可能性のあるフロントエンドの副作用に関して、改善の余地があります。

## 2. バックエンドコア (`backend/src/core`)

### アーキテクチャと設計
- **強み**:
    - `app_v2.py` (`TeporaApp`) で使用されている **Facade パターン** は、クリーンなエントリーポイントを提供し、コンポーネントのライフサイクルとオプションを効果的に管理しています。
    - **依存性の注入 (Dependency Injection)** が一貫して使用されており（例: `LLMService` や `ContextWindowManager` の `TeporaGraph` および各ノードへの伝播）、テスト容易性が促進されています。
    - `LLMService` の **ステートレス** 設計は、同時実行要件に的確に対応しています。

### コード品質と実装
- **同時実行性 (Concurrency)**: `LLMService` (`_model_locks`) における `asyncio.Lock` の使用は、スレッドセーフなモデルアクセスを保証するための重要かつ適切に実装された安全策です。
- **型安全性**: 型ヒントは存在しますが、`Any`（例: グラフノードにおける `dict[str, Any]`）が多用されており、型安全性が低下しています。
    - *推奨事項*: グラフの状態やツール入出力に対して、より強力な型付けを強制するために、`TypedDict` や Pydantic モデルをより広範囲に使用することを検討してください。
- **エラー処理**:
    - `TeporaGraph` のラッパー（例: `_tool_executor_wrapper`）では、例外が発生した場合に警告ログを出力して空の結果を返すことがよくあります。これによりクラッシュは防げますが、システムが劣化した状態で動作し続け、ユーザーがそれに気づかない「サイレント障害」につながる可能性があります。
    - *推奨事項*: 致命的でないエラーを UI のステータスやスクラッチパッドに伝播させ、ユーザーが認識できるようなメカニズム（例: 「Web 検索に失敗しました。内部知識を使用して続行します」）を実装してください。

### 具体的な発見事項
- **`app_v2.py`**:
    - `_try_decode_base64` と `_process_attachments` は、メインアプリケーションクラスに漏れ出したユーティリティロジックのように感じられます。これらを `AttachmentProcessor` などのユーティリティに移動すると、`TeporaApp` がすっきりします。
- **`llm/service.py`**:
    - `_count_tokens_via_server` は `127.0.0.1:{port}` に対して直接 HTTP 呼び出しを行っています。これは、ランナーが常にこの正確なエンドポイント構造を公開していることを前提としています。ランナーの実装が変更された場合（例: `llama-server` から `ollama` への切り替え）、これが機能しなくなる可能性があります。`Runner` インターフェースを通じた抽象化を行う方がよりクリーンです。
- **`rag/engine.py`**:
    - `_fetch_web_content` は文字列マッチング (`content.startswith("Error:")`) でエラーをチェックしています。これは壊れやすい実装です。基盤となるツールは、構造化された結果（成功/失敗オブジェクト）を返すか、特定の例外を発生させるべきです。

## 3. バックエンドサーバー (`backend/src/tepora_server`)

### アーキテクチャと設計
- **強み**:
    - `AppState` は、コアアプリケーションにアクセスするための明確なシングルトンを提供しています。
    - API ルートはクリーンで、検証に Pydantic を使用しています。
    - セキュリティミドルウェア (`SecurityUtils`) が、機密性の高いファイル操作に正しく適用されています。

### 具体的な発見事項
- **設定のリロード**: `update_config` は `_reload_config_manager()` を呼び出しています。これが、すでに初期化されたコンポーネントに伝播するかどうかは不明確です。例えば、`LLMService` は `__init__` で `cache_size` を読み込みます。API 経由で実行時にこの設定を変更しても、サーバーの完全な再起動を行わない限り反映されない可能性があります。
    - *推奨事項*: `TeporaApp` とその子コンポーネントに `reload_config()` エントリーポイントを実装し、実行時の設定変更を適用できるようにしてください。
- **自己終了 (Self-Termination)**: `shutdown_server` は `os.kill(os.getpid(), signal.SIGTERM)` を使用しています。効果的ではありますが、内部からシャットダウンするには唐突な方法です。データの破損（SQLite の WAL モードは通常これを処理しますが、明示的なクリーンアップの方が安全です）を引き起こさないことを確認してください。

## 4. フロントエンド (`frontend/src`)

### アーキテクチャと設計
- **強み**:
    - **Zustand** がグローバル状態管理（`chatStore`, `websocketStore`）に効果的に使用されています。
    - 「データ」(`chatStore`) と「トランスポート」(`websocketStore`) の分離は良いパターンです。
    - **パフォーマンス**: `websocketStore` はバッファリング戦略 (`CHUNK_FLUSH_INTERVAL`) を使用しており、高頻度のトークンストリーミング中の React の再レンダリングを最小限に抑えています。

### コード品質と実装
- **副作用**: `websocketStore.ts` にはグローバルな副作用が含まれています:
  ```typescript
  if (typeof window !== "undefined") {
      setTimeout(() => { useWebSocketStore.getState().connect(); }, 0);
  }
  ```
  モジュールのインポート時に自動接続するこの動作は、テストを困難にし（状態がテスト間でリークする）、コンシューマーの制御を低下させます。
  - *推奨事項*: グローバルな副作用を削除してください。ルートの `App.tsx` または `SessionManager` コンポーネント内の `useEffect` フックで `connect()` をトリガーするようにしてください。
- **再接続ロジック**: `onclose` 内のトークンリフレッシュロジックは `refreshSessionToken()` を呼び出しますが、次の `connect()` 試行をトリガーする `reconnectTimeout` の前にその完了を厳密に待機していません。これにより、古い/null トークンで再試行してしまう競合状態が発生する可能性があります。

## 5. デプロイメントと設定

- **Tauri 設定**:
    - CSP は概ね良好ですが、`connect-src ws://localhost:*` は非常に寛容です。
    - `devtools: true` は、リリースされたアプリで内部が露出するのを防ぐため、ビルドスクリプトや環境変数の置換を使用して、本番ビルドでは無効にすることが理想的です。

## 6. アクションプランの推奨事項

1.  **フロントエンドソケット初期化のリファクタリング**: `connect()` 呼び出しを `websocketStore.ts` のグローバルスコープから、メインの App コンポーネント内の `useEffect` に移動する。
2.  **バックエンドエラー処理の強化**: `TeporaGraph` ノードを見直し、エラーが単にログに記録されるだけでなく、エージェント状態 (Agent State) に報告され、UI が警告を表示できるようにする。
3.  **設定の伝播**: 実行時の設定更新（例: エージェント設定）が実際に実行中の `TeporaGraph` を更新するかどうかを確認する。もし更新されない場合は、`rebuild_graph()` メソッドを追加する。
4.  **型安全性**: `dict[str, Any]` を置き換えるために、すべてのグラフノードの入出力に対して厳密な Pydantic モデルを段階的に導入する。

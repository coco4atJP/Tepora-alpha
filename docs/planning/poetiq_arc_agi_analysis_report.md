# Poetiq ARC-AGI Solver 実装詳細・Deep Dive レポート

本レポートは、`projects/poetiq-arc-agi-solver-main` リポジトリがなぜState-of-the-Art (SOTA) の性能を達成できたのか、その「秘伝のタレ（Secret Sauce）」となる実装メカニズムを深掘りしたものです。

## 1. 成功の核心的要因 (Key Success Factors)

単なる「LLMに解かせる」アプローチを超え、以下の3つの高度なエンジニアリングが組み合わさっています。

1.  **Visual Diff Feedback (視覚的差分フィードバック)**: LLMに「間違った」と伝えるだけでなく、「どのピクセルがどう間違ったか」をグリッド形式で直感的に提示。
2.  **Diversity-First Voting (多様性優先の投票)**: 安易な多数決ではなく、異なるロジックで導かれた解を優先的に拾い上げるアンサンブル戦略。
3.  **Structured Chain-of-Thought (構造化された思考プロセス)**: 人間のエキスパートの思考過程を模倣させる、非常に詳細かつ拘束力の強いプロンプト。

---

## 2. 詳細分析

### 2.1. Visual Diff Feedback メカニズム

通常、コード生成に失敗すると「Error」や「Output mismatch」とだけ伝えがちですが、本システムは極めて詳細なデバッグ情報を生成します。

- **実装箇所**: `arc_agi/solve_coding.py` -> `_build_feedback` & `_array_diff`
- **動作**:
    - トレーニング例で正解しなかった場合、予測出力と正解出力の形状(Shape)を比較します。
    - 形状が一致している場合、**セル単位の差分**を作成します。
    - 正解したセルはそのままの値、間違ったセルは `予測値/正解値` (例: `1/5`) という形式で埋め込まれたグリッドを提示します。

**プロンプトへの注入例**:
```text
Solves Example #1 incorrectly.
...
Below is a visualization...
1 1 0/2
1 0/5 1
```
これにより、LLMは「座標(0, 2)は2にすべきところを0にしてしまった」と具体的に認識でき、修正（例えば「右上のピクセル処理が抜けている」など）が容易になります。

### 2.2. Diversity-First Voting 戦略

並列実行（アンサンブル）において、単に最も多い答えを選ぶと、LLMが陥りやすい「もっともらしいが間違った答え」に引っ張られるリスクがあります。本システムはこれを回避しています。

- **実装箇所**: `arc_agi/solve_parallel_coding.py`
- **アルゴリズム**:
    1.  全てのエキスパートの実行結果を、**出力されたグリッド（Test Output）が同じもの**同士でグループ化します（`candidate_buckets`）。
    2.  各グループから「代表選手（Best Member）」を1つ選びます。
        - デフォルトでは反復回数が最も少ない（素早く解けた）解などが優先されます (`iters_tiebreak`)。
    3.  グループ自体を「投票数（支持したエキスパート数）」の多い順に並べます。
    4.  **ここが重要**: 提出リスト（`ordered`）を作成する際、**各グループの代表選手を順に並べます**。
        - 1位: 最も支持が多いグループの代表
        - 2位: 2番目に支持が多いグループの代表（※1位とは異なる出力）
        - ...

この「各グループから1つずつ」という戦略（Diversity-First）により、提出枠（Kaggleでは2回）の中に、全く異なるアプローチの解を含めることができ、正解率を最大化しています。

### 2.3. Meta-Cognitive Prompting (メタ認知的プロンプト)

`SOLVER_PROMPT` は単なる指示ではなく、問題解決のアルゴリズムそのものをLLMにインストールしています。

- **実装箇所**: `arc_agi/prompts.py`
- **構成**:
    1.  **Analysis**: 物体、関係性、操作、対称性を分析せよ。
    2.  **Hypothesis**: 色、分離、空間操作などのカテゴリから仮説を立てよ（「単純なものから優先せよ」という指針付き）。
    3.  **Implementation**: コード実装。
    4.  **Test and Refine**: 自己検証のステップ。

特に `SOLVER_PROMPT_2` では "Refinement"（改善）のプロセスが強く意識されており、人間が試行錯誤する様をシミュレートさせています。

---

## 3. その他の技術的工夫

- **Soft Score**: 正解・不正解の0/1だけでなく、ピクセル一致率 (`_soft_score`) を計算しています。これは「失敗した試行」の中から「惜しい」ものを見つけて優先順位付けするために使用されます（Failure Bucketsのソート）。
- **Execution Safety**: `process` や `resource` 制限を用いたサンドボックス実行ではなく、単純な `exec` ですが、タイムアウトや例外処理は `asyncio` で厳格に管理されています。

## 4. 結論

Poetiq Solverの強さは、高度なAIモデルを使っていること以上に、**「LLMの出力を精査し、間違いを具体的に指摘し、多様な可能性を捨てない」** という、周辺の制御ロジックの優秀さにあります。
特に **Visual Diff Feedback** は、LLMの空間推論能力の限界を補う強力な手段となっており、これがSOTA達成の最大の要因であると推測されます。
